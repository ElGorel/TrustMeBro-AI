import random
from enum import Enum

# Definimos constantes para facilitar la lectura del código a tus compañeros
class Ubicacion(Enum):
    IZQUIERDA = 0
    DERECHA = 1

class EstadoJuego(Enum):
    EN_PROGRESO = "Jugando"
    GANADO = "¡Encontraste el tesoro!"
    PERDIDO = "Caíste en una trampa"

class MotorJuego:
    def __init__(self):
        """
        Constructor: Inicializa las estadísticas globales.
        """
        self.rondas_jugadas = 0
        self.victorias = 0
        self.derrotas = 0
        self.reset_ronda() # Prepara la primera ronda

    def reset_ronda(self):
        """
        Reinicia el estado para una nueva partida (o episodio de entrenamiento).
        Define aleatoriamente dónde está el tesoro y dónde la trampa.
        """
        self.estado_actual = EstadoJuego.EN_PROGRESO
        
        # 0 = Izquierda, 1 = Derecha (Se puede ampliar a más opciones fácilmente)
        opciones = [Ubicacion.IZQUIERDA, Ubicacion.DERECHA]
        
        self.posicion_tesoro = random.choice(opciones)
        
        # La trampa está en el lugar opuesto al tesoro
        if self.posicion_tesoro == Ubicacion.IZQUIERDA:
            self.posicion_trampa = Ubicacion.DERECHA
        else:
            self.posicion_trampa = Ubicacion.IZQUIERDA
            
        return self.get_info_estado()

    def evaluar_jugada(self, eleccion_jugador):
        """
        Recibe la decisión del jugador (o del Bot) y determina el resultado.
        
        Args:
            eleccion_jugador (Ubicacion): Ubicacion.IZQUIERDA o Ubicacion.DERECHA
        
        Returns:
            dict: Información completa del resultado para la UI y la IA.
        """
        if self.estado_actual != EstadoJuego.EN_PROGRESO:
            raise Exception("La ronda ya terminó. Ejecuta reset_ronda() primero.")

        if eleccion_jugador == self.posicion_tesoro:
            self.estado_actual = EstadoJuego.GANADO
            self.victorias += 1
        else:
            self.estado_actual = EstadoJuego.PERDIDO
            self.derrotas += 1

        self.rondas_jugadas += 1
        
        return self.get_info_estado()

    def get_ubicacion_real_tesoro(self):
        """
        ¡IMPORTANTE! Este método es lo que el NPC (Rol 3) consultará
        para decidir si miente o dice la verdad.
        El jugador humano NO debe tener acceso a esto directamente.
        """
        return self.posicion_tesoro

    def get_info_estado(self):
        """
        Devuelve el estado actual del juego en un formato útil (Diccionario).
        """
        return {
            "estado": self.estado_actual,
            "rondas_totales": self.rondas_jugadas,
            "score": f"{self.victorias} - {self.derrotas}",
            "tesoro_real": self.posicion_tesoro if self.estado_actual != EstadoJuego.EN_PROGRESO else "OCULTO"
        }

# --- BLOQUE DE PRUEBA (Solo para ti) ---
if __name__ == "__main__":
    # Esto te permite probar tu código sin necesitar a tus compañeros.
    print("--- Probando el Motor Lógico ---")
    juego = MotorJuego()
    
    print(f"Inicio: El tesoro se ha escondido. (Secreto para debug: {juego.posicion_tesoro.name})")
    
    # Simulamos que el jugador elige IZQUIERDA
    decision = Ubicacion.IZQUIERDA
    print(f"Jugador elige: {decision.name}")
    
    resultado = juego.evaluar_jugada(decision)
    print(f"Resultado: {resultado['estado'].value}")
    print(f"Marcador Global: {resultado['score']}")
